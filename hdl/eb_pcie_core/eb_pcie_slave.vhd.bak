library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
--use work.pcie_wb_pkg.all;
use work.wishbone_pkg.all;
use work.etherbone_pkg.all;
use work.eb_internals_pkg.all;
use work.eb_hdr_pkg.all;

entity eb_pcie_slave is
  generic(
    g_fast_ack     : boolean := true;
    g_sdb_address  : t_wishbone_address
  );
  port(
    clk_wb_i      : in  std_logic; -- clock from PCI WB side
    rstn_wb_i     : in  std_logic;    
    
    clk_xwb_i     : in  std_logic; -- clock from XWB side
    rstn_xwb_i    : in  std_logic;

    -- Command from PC to EB slave
    slave_i       : in  t_wishbone_slave_in := cc_dummy_slave_in;
    slave_o       : out t_wishbone_slave_out;
    
    -- Commands from EB slave to XWB crossbar
    master_o      : out t_wishbone_master_out;
    master_i      : in  t_wishbone_master_in;
    
    phy_cyc_o     : out std_logic
    );
end eb_pcie_slave;

architecture rtl of eb_pcie_slave is

  constant c_CFG_REG_ARRAY_START    : std_logic_vector(3 downto 0) := x"0";  
  constant c_RX_FIFO_DATA           : std_logic_vector(3 downto 0) := x"8";
  constant c_TX_FIFO_DATA           : std_logic_vector(3 downto 0) := x"C";  
  
  constant c_CFG_REG_CYCLE      : std_logic_vector(2 downto 0) := "000";
  constant c_CFG_REG_STATUS     : std_logic_vector(2 downto 0) := "001";  
  constant c_CFG_REG_SCRATCH1   : std_logic_vector(2 downto 0) := "110";
  constant c_CFG_REG_SCRATCH2   : std_logic_vector(2 downto 0) := "111";

  signal pci_tx_fifo_full   : std_logic;
  signal pci_tx_fifo_we     : std_logic;
  signal pci_tx_fifo_dati   : std_logic_vector(31 downto 0);
  
  signal pci_tx_fifo_empty  : std_logic;
  signal pci_tx_fifo_re     : std_logic;
  signal pci_tx_fifo_dato   : std_logic_vector(31 downto 0);

  signal pci_rx_fifo_full   : std_logic;
  signal pci_rx_fifo_we     : std_logic;
  signal pci_rx_fifo_dati   : std_logic_vector(31 downto 0);
  
  signal pci_rx_fifo_empty  : std_logic;
  signal pci_rx_fifo_re     : std_logic;
  signal pci_rx_fifo_dato   : std_logic_vector(31 downto 0);
  
  
  signal pci_rx_fifo_master_o : t_wishbone_master_out;
  signal pci_rx_fifo_master_i : t_wishbone_master_in;
  
  signal eb_rx_stream_master_o  : t_wishbone_master_out;
  signal eb_rx_stream_master_o2 : t_wishbone_master_out;  
  signal eb_rx_stream_master_i  : t_wishbone_master_in;
  
  signal eb_slave_int_master_o  : t_wishbone_master_out;
  signal eb_slave_int_master_o2 : t_wishbone_master_out;
  signal eb_slave_int_master_i  : t_wishbone_master_in;
  
  signal eb_tx_fifo_master_o    : t_wishbone_master_out;
  signal eb_tx_fifo_master_i    : t_wishbone_master_in;
  
  signal eb_rx_stream_master_cyc_sync : std_logic_vector(1 downto 0);
  
  
  -- internal register to hold cycle line
  signal r_cyc      : std_logic;
  signal r_int_cyc  : std_logic;
  
  signal r_scratch  : std_logic_vector(31 downto 0);
  
begin




  slave_o.ack   <= slave_i.stb;          
  slave_o.err   <= '0';                  
  slave_o.rty   <= '0';                  
  slave_o.stall <= pci_rx_fifo_full;     
  slave_o.int   <= not pci_tx_fifo_empty;


  -- internal register space
  p_cfg_reg: process(clk_wb_i)
  begin
    if rising_edge(clk_wb_i) then

        slave_o.ack   <= slave_i.stb;
        
        -- control bar
        if slave_i.adr(5) = '0' then
            -- configuration registers
            case slave_i.adr(4 downto 2) is
                when c_CFG_REG_CYCLE =>
                    slave_o.dat(31) <= r_cyc;
                    slave_o.dat(30 downto 0) <= (others => '0');
                    
                when c_CFG_REG_STATUS => 
                    slave_o.dat(0) <= not pci_tx_fifo_empty;
                    slave_o.dat(1) <= pci_rx_fifo_full;
                    slave_o.dat(30 downto 0) <= (others => '0');
                    
                when c_CFG_REG_SCRATCH2 =>
                    slave_o.dat <= r_scratch;
                    
                when others => x"DEADC0DE";

            -- writes
            if slave_i.stb = '1' and slave_i.we  = '1' then
                -- configuration registers
                case slave_i.adr(4 downto 2) is
                    when c_CFG_REG_CYCLE =>
                        if slave_i.dat(30) = '1' then
                            r_cyc <= slave_i.dat(31);
                        end if;
                    when c_CFG_REG_SCRATCH1 =>
                        r_scratch <= slave_i.dat;
                    when others => null;
            end if;
        else
            slave_o.dat <= pci_tx_fifo_dato;
        end if;
    end if;
  end process;

  -- pass out for use with issp
  phy_cyc_o <= r_cyc;
  
  
  pci_tx_fifo_re   <= '1' when (slave_i.adr(5 downto 2) = c_TX_FIFO_DATA and
                                slave_i.we  = '0' and 
                                slave_i.stb = '1'
                                )
                       else '0';
  
  pci_tx_fifo_we <= '1' when (eb_tx_fifo_master_o.we  = '1' and 
                              eb_tx_fifo_master_o.stb = '1'                           
                             )
                    else '0';
  
  pci_tx_fifo_dati <= eb_tx_fifo_master_o.dat;
  
  eb_tx_fifo_master_i.ack   <= eb_tx_fifo_master_o.stb;
  eb_tx_fifo_master_i.err   <= '0';
  eb_tx_fifo_master_i.rty   <= '0';
  eb_tx_fifo_master_i.stall <= pci_tx_fifo_full;
  eb_tx_fifo_master_i.int   <= '0';
  eb_tx_fifo_master_i.dat   <= (others => '0');
  
--  -- holds EB reply packets to be read by wishbone kernel module
--  pci_tx_fifo : eb_fifo
--    generic map(
--      g_width => c_wishbone_data_width,
--      g_size  => 1024)
--    port map(
--      clk_i                           => clk_wb_i,
--      rstn_i                          => rstn_wb_i,
--      -- writer side
--      w_full_o                        => pci_tx_fifo_full,
--      w_push_i                        => pci_tx_fifo_we  ,
--      w_dat_i(t_wishbone_data'range)  => pci_tx_fifo_dati,
--     
--      -- reader side
--      r_empty_o                       => pci_tx_fifo_empty,
--      r_pop_i                         => pci_tx_fifo_re   ,
--      r_dat_o(t_wishbone_data'range)  => pci_tx_fifo_dato 
--    );    

    
pci_tx_fifo: entity work.generic_async_fifo
  generic map(
    g_data_width => 32, -- natural;
    g_size       => 64, -- natural;
    g_show_ahead => true, -- boolean := false;

    -- Read-side flag selection
    g_with_rd_empty        => true , -- boolean := true;   -- with empty flag
    g_with_rd_full         => false, -- boolean := false;  -- with full flag
    g_with_rd_almost_empty => false, -- boolean := false;
    g_with_rd_almost_full  => false, -- boolean := false;
    g_with_rd_count        => false, -- boolean := false;  -- with words counter

    g_with_wr_empty        => false, -- boolean := false;
    g_with_wr_full         => true , -- boolean := true;
    g_with_wr_almost_empty => false, -- boolean := false;
    g_with_wr_almost_full  => false, -- boolean := false;
    g_with_wr_count        => false, -- boolean := false;

    g_almost_empty_threshold => 16, -- integer;  -- threshold for almost empty flag
    g_almost_full_threshold  => 16  -- integer   -- threshold for almost full flag
    )
  port map (
    rst_n_i => rstn_wb_i, -- in std_logic := '1';


    -- write port - eb slave source
    clk_wr_i => clk_xwb_i, -- in std_logic;
    d_i      => pci_tx_fifo_dati, -- in std_logic_vector(g_data_width-1 downto 0);
    we_i     => pci_tx_fifo_we, -- in std_logic;

--    wr_empty_o        => , --  out std_logic;
    wr_full_o         => pci_tx_fifo_full, --  out std_logic;
--    wr_almost_empty_o => , --  out std_logic;
--    wr_almost_full_o  => , --  out std_logic;
--    wr_count_o        => , --  out std_logic_vector(f_log2_size(g_size)-1 downto 0);

    -- read port - pci wb side
    clk_rd_i => clk_wb_i, -- in  std_logic;
    q_o      => pci_tx_fifo_dato, -- out std_logic_vector(g_data_width-1 downto 0);
    rd_i     => pci_tx_fifo_re, -- in  std_logic;

    rd_empty_o        => pci_tx_fifo_empty -- out std_logic;
--    rd_full_o         => , -- out std_logic;
--    rd_almost_empty_o => , -- out std_logic;
--    rd_almost_full_o  => , -- out std_logic;
--    rd_count_o        =>   -- out std_logic_vector(f_log2_size(g_size)-1 downto 0)
    );    
    
    

  -- RX FIFO write
  pci_rx_fifo_we   <= '1' when (slave_i.adr(5 downto 2) = c_RX_FIFO_DATA and
                                slave_i.we  = '1' and 
                                slave_i.stb = '1'
                                )
                       else '0';
  pci_rx_fifo_dati <= slave_i.dat;

    
  
--  -- holds EB request packets sent from wishbone kernel module
--  pci_rx_fifo : eb_fifo
--    generic map(
--      g_width => c_wishbone_data_width,
--      g_size  => 128)
--    port map(
--      clk_i                           => clk_wb_i ,
--      rstn_i                          => rstn_wb_i,
--      -- writer side
--      w_full_o                        => pci_rx_fifo_full,
--      w_push_i                        => pci_rx_fifo_we  ,
--      w_dat_i(t_wishbone_data'range)  => pci_rx_fifo_dati,
--      
--      -- reader side
--      r_empty_o                       => pci_rx_fifo_empty,
--      r_pop_i                         => pci_rx_fifo_re   ,
--      r_dat_o(t_wishbone_data'range)  => pci_rx_fifo_dato
--    );  

    
pci_rx_fifo: entity work.generic_async_fifo
  generic map(
    g_data_width => 32, -- natural;
    g_size       => 64, -- natural;
    g_show_ahead => false, -- boolean := false;

    -- Read-side flag selection
    g_with_rd_empty        => true , -- boolean := true;   -- with empty flag
    g_with_rd_full         => false, -- boolean := false;  -- with full flag
    g_with_rd_almost_empty => false, -- boolean := false;
    g_with_rd_almost_full  => false, -- boolean := false;
    g_with_rd_count        => false, -- boolean := false;  -- with words counter

    g_with_wr_empty        => false, -- boolean := false;
    g_with_wr_full         => true , -- boolean := true;
    g_with_wr_almost_empty => false, -- boolean := false;
    g_with_wr_almost_full  => false, -- boolean := false;
    g_with_wr_count        => false, -- boolean := false;

    g_almost_empty_threshold => 16, -- integer;  -- threshold for almost empty flag
    g_almost_full_threshold  => 16  -- integer   -- threshold for almost full flag
    )
  port map (
    rst_n_i => rstn_wb_i, -- in std_logic := '1';


    -- write port - eb slave source
    clk_wr_i => clk_wb_i, -- in std_logic;
    d_i      => pci_rx_fifo_dati, -- in std_logic_vector(g_data_width-1 downto 0);
    we_i     => pci_rx_fifo_we, -- in std_logic;

--    wr_empty_o        => , --  out std_logic;
    wr_full_o         => pci_rx_fifo_full, --  out std_logic;
--    wr_almost_empty_o => , --  out std_logic;
--    wr_almost_full_o  => , --  out std_logic;
--    wr_count_o        => , --  out std_logic_vector(f_log2_size(g_size)-1 downto 0);

    -- read port - pci wb side
    clk_rd_i => clk_xwb_i, -- in  std_logic;
    q_o      => pci_rx_fifo_dato, -- out std_logic_vector(g_data_width-1 downto 0);
    rd_i     => pci_rx_fifo_re, -- in  std_logic;

    rd_empty_o        => pci_rx_fifo_empty -- out std_logic;
--    rd_full_o         => , -- out std_logic;
--    rd_almost_empty_o => , -- out std_logic;
--    rd_almost_full_o  => , -- out std_logic;
--    rd_count_o        =>   -- out std_logic_vector(f_log2_size(g_size)-1 downto 0)
    );    
    
    
    
  -- read what was written by PC to FIFO 
  -- only when there is something to read and slave is ready to accept it
  pci_rx_fifo_re <= '1' when  (eb_rx_stream_master_i.stall = '0' and 
                               pci_rx_fifo_empty           = '0'
                              )
                   else '0';                              

  
  -- push data from FIFO to slave only when there is something to read and slave is ready to accept it
  --eb_rx_stream_master_o.stb <= not pci_rx_fifo_empty and not eb_rx_stream_master_i.stall;
  
  p_rx_sm_stb_cyc: process(clk_xwb_i)
  begin
    if rising_edge(clk_xwb_i) then
        if rstn_xwb_i = '0' then
            eb_rx_stream_master_o.stb    <= '0';
            eb_rx_stream_master_cyc_sync <= (others => '0');
        else
            -- push data from FIFO to slave only when new data was read
            eb_rx_stream_master_o.stb <= pci_rx_fifo_re;
            -- sync to xwb clock domain
            eb_rx_stream_master_cyc_sync <= r_cyc & eb_rx_stream_master_cyc_sync(eb_rx_stream_master_cyc_sync'left downto 1);
        end if;
    end if;
  end process;
  
  
  -- comes from 
  eb_rx_stream_master_o.cyc <= eb_rx_stream_master_cyc_sync(0);

  
  -- dont care
  eb_rx_stream_master_o.adr <= (others => '0');
  eb_rx_stream_master_o.sel <= x"F";
  eb_rx_stream_master_o.we  <= '1';
  eb_rx_stream_master_o.dat <= pci_rx_fifo_dato;


  EB : eb_slave_top
    generic map(
      g_sdb_address    => g_sdb_address(31 downto 0),
      g_timeout_cycles => 4)
    port map(
      clk_i        => clk_xwb_i ,
      nRst_i       => rstn_xwb_i,

      EB_RX_o      => eb_rx_stream_master_i,
      EB_RX_i      => eb_rx_stream_master_o,

      EB_TX_i      => eb_tx_fifo_master_i,
      EB_TX_o      => eb_tx_fifo_master_o,

      skip_stb_o   => open,
      skip_stall_i => '0',

      WB_master_i  => eb_slave_int_master_i,
      WB_master_o  => eb_slave_int_master_o,

      WB_config_i  => cc_dummy_slave_in, --cfg_slave_i,
      WB_config_o  => open, --cfg_slave_o,

      my_mac_o     => open,
      my_ip_o      => open,
      my_port_o    => open
    );  
  
--  eb_slave_int_master_o2.stb <= '1' when eb_slave_int_master_o.stb = '1' 
--                                        -- when PCI side drops cycle line do fake write just 
--                                        -- to drop cycle on the xwb side low
--                                        or (r_int_cyc = '1' and slave_i.cyc = '0')
--                                else '0';
--                                
--  eb_slave_int_master_o2.cyc <= eb_slave_int_master_o.cyc;
--  eb_slave_int_master_o2.adr <= eb_slave_int_master_o.adr;
--  eb_slave_int_master_o2.sel <= eb_slave_int_master_o.sel;
--  eb_slave_int_master_o2.we  <= eb_slave_int_master_o.we;
--  eb_slave_int_master_o2.dat <= eb_slave_int_master_o.dat;
--
--  PC_to_FPGA_clock_crossing_eb : xwb_clock_crossing 
--    generic map(g_size => 32) port map(
--    slave_clk_i    => clk_wb_i ,
--    slave_rst_n_i  => rstn_wb_i,
--
--    slave_i        => eb_slave_int_master_o2,
--    slave_o        => eb_slave_int_master_i,
--    
--    master_clk_i   => clk_xwb_i ,
--    master_rst_n_i => rstn_xwb_i,
--    
--    master_i       => master_i,
--    master_o       => master_o
--  );

    
    eb_slave_int_master_i   <= master_i;
    master_o                <= eb_slave_int_master_o;


  
  
end rtl;
