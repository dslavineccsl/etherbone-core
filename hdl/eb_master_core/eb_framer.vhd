--! @file eb_framer.vhd
--! @brief Produces EB content from WB operations
--!        
--!
--! Copyright (C) 2013-2014 GSI Helmholtz Centre for Heavy Ion Research GmbH 
--!
--! Muxes adress / data lines and inserts meta data generated by eb_record_gen
--!
--! @author Mathias Kreider <m.kreider@gsi.de>
--!
--------------------------------------------------------------------------------
--! This library is free software; you can redistribute it and/or
--! modify it under the terms of the GNU Lesser General Public
--! License as published by the Free Software Foundation; either
--! version 3 of the License, or (at your option) any later version.
--!
--! This library is distributed in the hope that it will be useful,
--! but WITHOUT ANY WARRANTY; without even the implied warranty of
--! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--! Lesser General Public License for more details.
--!  
--! You should have received a copy of the GNU Lesser General Public
--! License along with this library. If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------------

--! Standard library
library IEEE;
--! Standard packages   
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.wishbone_pkg.all;
use work.genram_pkg.all;
use work.eb_hdr_pkg.all;
use work.etherbone_pkg.all;
use work.eb_internals_pkg.all;

entity eb_framer is
  port(
    clk_i           : in   std_logic;            -- WB Clock
    rst_n_i         : in   std_logic;            -- async reset

    slave_i         : in   t_wishbone_slave_in;  
    slave_o         : out  t_wishbone_slave_out; 
    master_o        : out  t_wishbone_master_out;
    master_i        : in   t_wishbone_master_in; 
    
    byte_cnt_o      : out  std_logic_vector(15 downto 0);
    ovf_o           : out  std_logic;
    busy_o          : out  std_logic;
       
    tx_send_now_i   : in   std_logic;
    tx_flush_o      : out  std_logic; 
    length_i        : in   unsigned(15 downto 0); 
    cfg_rec_hdr_i   : in   t_rec_hdr -- EB cfg information, eg read from cfg space etc
);   
end eb_framer;

architecture rtl of eb_framer is

--signals


signal s_slave_stall,
       r_slave_ack    : std_logic;
signal send_now,
       s_tx_send_now,
       r_tx_send_now  : std_logic; -- queued version


signal tx_cyc         : std_logic;
signal tx_stb         : std_logic;
signal r_abort        : std_logic;
signal s_space_sufficient : std_logic;  
signal s_rec_byte_cnt,
       r_rec_byte_cnt,
       s_word_cnt : unsigned(15 downto 0);

constant c_op_fifo_width : natural := 32+1;
signal op_fifo_q      : std_logic_vector(c_op_fifo_width-1 downto 0);
signal op_fifo_d      : std_logic_vector(c_op_fifo_width-1 downto 0);
signal op_fifo_push   : std_logic;
signal op_fifo_pop    : std_logic;
signal op_fifo_full   : std_logic;
signal op_fifo_empty  : std_logic;
signal r_pop_cmd      : std_logic;
signal s_tx_push      : std_logic;

constant c_rec_fifo_width : natural := 32+32+32;
signal rec_fifo_q      : std_logic_vector(c_rec_fifo_width-1 downto 0);
signal rec_fifo_d      : std_logic_vector(c_rec_fifo_width-1 downto 0);
signal rec_fifo_push   : std_logic;
signal rec_fifo_pop    : std_logic;
signal rec_fifo_full   : std_logic;
signal rec_fifo_empty  : std_logic;

signal s_rec_hdr_o      : t_rec_hdr;

signal s_busy           : std_logic;
signal s_rec_ack        : std_logic;
signal s_rec_adr_rd_o   : t_wishbone_data;      -- EB write base address
signal s_rec_adr_wr_o   : t_wishbone_address;   -- EB read back address

signal s_recgen_slave_stall : std_logic;
signal adr_wr         : t_wishbone_address;
signal adr_rd         : t_wishbone_address;
signal rec_hdr        : t_rec_hdr;
signal r_eb_hdr       : t_eb_hdr;

-- FSMs
type t_mux_state is (s_INIT, s_IDLE, s_EB, s_REC, s_WA, s_RA, s_WRITE, s_READ, s_LOAD, s_NEXT, s_SEND, s_ERROR);
signal r_state,
       s_state_next   : t_mux_state;

signal r_ops_cnt,
       s_ops_cnt_next : unsigned(8 downto 0);
signal r_byte_cnt,
       s_byte_cnt_next : unsigned(15 downto 0);

signal s_recgen_slave_i  : t_wishbone_slave_in;

function or_all(slv_in : std_logic_vector)
return std_logic is
variable I : natural;
variable ret : std_logic;
begin
  ret := '0';
  for I in 0 to slv_in'left loop
   ret := ret or slv_in(I);
  end loop;    
  return ret;
end function or_all;



function to_unsigned(b_in : std_logic; bits : natural)
return unsigned is
variable ret : std_logic_vector(bits-1 downto 0) := (others=> '0');
begin
  ret(0) := b_in;
  return unsigned(ret);
end function to_unsigned;

begin
------------------------------------------------------------------------------
-- IO assignments
------------------------------------------------------------------------------

  busy_o              <= tx_cyc or s_busy;
  s_slave_stall       <= (op_fifo_full or not s_space_sufficient or s_recgen_slave_stall);
  s_space_sufficient  <= '1' when r_byte_cnt <= length_i
                    else '0';
  ovf_o               <= not s_space_sufficient;
  byte_cnt_o          <= std_logic_vector(r_byte_cnt);
  

  s_word_cnt        <=  (1 + to_unsigned(or_all(std_logic_vector(rec_hdr.rd_cnt)), 16)
                          + to_unsigned(or_all(std_logic_vector(rec_hdr.wr_cnt)), 16) 
                          + rec_hdr.rd_cnt  
                          + rec_hdr.wr_cnt);
          

  slave_o.stall   <= s_slave_stall;
  slave_o.dat     <= (others => '0');
  slave_o.ack     <= r_slave_ack;
  slave_o.err     <= '0'; 
 
  s_recgen_slave_i.cyc  <= slave_i.cyc;
  s_recgen_slave_i.stb  <= slave_i.stb and not (op_fifo_full or not s_space_sufficient);
  s_recgen_slave_i.we   <= slave_i.we;
  s_recgen_slave_i.sel  <= slave_i.sel;
  s_recgen_slave_i.adr  <= slave_i.adr;
  s_recgen_slave_i.dat  <= slave_i.dat;
   
 
 --------------------
 
  rgen: eb_record_gen 
  PORT MAP (
         
      clk_i           => clk_i,
      rst_n_i         => rst_n_i,

      slave_i         => s_recgen_slave_i,
      slave_stall_o   => s_recgen_slave_stall,
      slave_ack_o     => open,
      
      rec_ack_i       => s_rec_ack,
      
      rec_valid_o     => rec_fifo_push,
      rec_hdr_o       => s_rec_hdr_o,
      rec_adr_rd_o    => s_rec_adr_rd_o, 
      rec_adr_wr_o    => s_rec_adr_wr_o,
      byte_cnt_o      => s_rec_byte_cnt, --s_rec_word_cnt,
      busy_o          => s_busy,
      cfg_rec_hdr_i   => cfg_rec_hdr_i); 
 
     

------------------------------------------------------------------------------
-- fifos
------------------------------------------------------------------------------
  
    op_fifo : generic_sync_fifo
    generic map(
      g_data_width             => c_op_fifo_width,
      g_size                   => 256,
      g_show_ahead             => true,
      g_with_empty             => true,
      g_with_full              => true,
      g_with_almost_full       => false)
    port map (
      clk_i   => clk_i,
      rst_n_i => rst_n_i,
      full_o  => op_fifo_full,
      we_i    => op_fifo_push,
      d_i     => op_fifo_d,
      empty_o => op_fifo_empty,
      rd_i    => op_fifo_pop,
      q_o     => op_fifo_q,
      count_o => open);  
  
  s_tx_push       <= (tx_cyc and tx_stb and not master_i.stall);
  op_fifo_pop     <= (s_tx_push or send_now) and r_pop_cmd and not op_fifo_empty;
  op_fifo_push    <= ((slave_i.cyc and slave_i.stb and not s_slave_stall) or s_tx_send_now) and not op_fifo_full;
  op_fifo_d(31 downto 0) <= slave_i.dat when slave_i.we = '1'
                else slave_i.adr;
  op_fifo_d(32) <= s_tx_send_now;

  --prolong tx_send_now if the buffer is full until it can be written
  s_tx_send_now         <= r_tx_send_now or tx_send_now_i;
  -- send must be in order, so it comes from the op buffer
  send_now              <= op_fifo_q(32) when op_fifo_empty = '0' else '0';

  record_fifo : generic_sync_fifo
    generic map(
      g_data_width             => 32+32+32,
      g_size                   => 16,
      g_show_ahead             => true,
      g_with_empty             => true,
      g_with_full              => true,
      g_with_almost_full       => false)
    port map (
      clk_i   => clk_i,
      rst_n_i => rst_n_i,
      full_o  => rec_fifo_full,
      we_i    => rec_fifo_push,
      d_i     => rec_fifo_d,
      empty_o => rec_fifo_empty,
      rd_i    => rec_fifo_pop,
      q_o     => rec_fifo_q,
      count_o => open); 
  
		
	rec_fifo_d  <= f_format_rec(s_rec_hdr_o) & s_rec_adr_wr_o & s_rec_adr_rd_o;
  
  rec_hdr     <= f_parse_rec(rec_fifo_q(95 downto 64));
  adr_wr      <= rec_fifo_q(63 downto 32);
  adr_rd      <= rec_fifo_q(31 downto 0); 
  
   
  s_rec_ack   <= not rec_fifo_full;
              
  
  
  master_o.cyc <= tx_cyc;
  master_o.stb <= tx_stb;
  master_o.we  <= '1';
  master_o.sel <= (others => '1');
  master_o.adr <= (others => '0');
------------------------------------------------------------------------------
-- Output Mux
------------------------------------------------------------------------------
  r_eb_hdr  <= c_eb_init;
  
  OMux : with r_state select
  master_o.dat <= op_fifo_q(31 downto 0)  when s_WRITE | s_READ,
               f_format_rec(rec_hdr)  when s_REC,
               adr_wr                  when s_WA,
               adr_rd                  when s_RA, 
               f_format_eb(r_eb_hdr)   when s_EB,
               (others => '0')         when others;
               
           

  p_fsm_sync : process (clk_i) is
  begin
    if rising_edge(clk_i) then
      if rst_n_i = '0' then
        r_state         <= s_INIT;
        r_byte_cnt      <= (others => '0');
        r_ops_cnt       <= (others => '0');  
        r_tx_send_now   <= '0';
      else  
        r_state     <= s_state_next;
        r_byte_cnt  <= s_byte_cnt_next;
        r_ops_cnt   <= s_ops_cnt_next;  


        r_slave_ack     <= (slave_i.cyc and slave_i.stb and not s_slave_stall);
        r_rec_byte_cnt  <= s_word_cnt(13 downto 0) & "00";
        r_tx_send_now   <= (r_tx_send_now or tx_send_now_i) and op_fifo_full; --prolong tx_send_now if the buffer is full until it can be written 
      end if;
    end if;
  end process;





  p_fsm_logic : process (master_i.stall, rec_fifo_empty, r_state, r_ops_cnt, send_now, s_space_sufficient, rec_hdr.rd_cnt, rec_hdr.wr_cnt) is
  
  begin
    case r_state is
      when s_INIT   =>  tx_cyc        <= '0';
                        tx_flush_o    <= '0';
                        tx_stb        <= '0';  
                        rec_fifo_pop  <= '0'; 
                        r_pop_cmd     <= '0';

                        s_byte_cnt_next <= (others => '0');
                        s_ops_cnt_next  <= (others => '0');   

                        s_state_next <= s_IDLE;

      when s_IDLE   =>  tx_cyc        <= '0';
                        tx_flush_o    <= '0';
                        tx_stb        <= '0';  
                        rec_fifo_pop  <= '0'; 
                        r_pop_cmd     <= '0';

                        s_byte_cnt_next <= (others => '0');
                        s_ops_cnt_next  <= (others => '0');        

                        if(rec_fifo_empty = '0') then
                          s_state_next <= s_EB;
                        else
                          s_state_next <= r_state; 
                        end if;
                        
      when s_EB     =>  tx_cyc        <= '1';
                        tx_flush_o    <= '1';
                        tx_stb        <= '1';  
                        rec_fifo_pop  <= '0'; 
                        r_pop_cmd     <= '0';
                      
                        s_ops_cnt_next  <= r_ops_cnt;

                        if(master_i.stall = '0') then
                          s_byte_cnt_next <= r_byte_cnt +4;
                          s_state_next <= s_REC; -- output EB hdr
                        else
                          s_byte_cnt_next <= r_byte_cnt;
                          s_state_next    <= r_state;   
                        end if;
                        
      when s_REC    =>  tx_cyc        <= '1';
                        tx_flush_o    <= '0';
                        tx_stb        <= '1';  
                        rec_fifo_pop  <= '0'; 
                        r_pop_cmd     <= '0';

                        s_ops_cnt_next  <= r_ops_cnt;

                        if(master_i.stall = '0' and rec_fifo_empty = '0') then -- output record hdr
                          s_byte_cnt_next <= r_byte_cnt + r_rec_byte_cnt;                                
                          if(or_all(std_logic_vector(rec_hdr.wr_cnt))= '1') then
                            s_state_next <= s_WA;
                          elsif(or_all(std_logic_vector(rec_hdr.rd_cnt)) = '1') then
                            s_state_next <= s_RA;
                          else
                            s_state_next <= s_NEXT;
                          end if;
                        else
                          s_state_next    <= r_state; 
                          s_byte_cnt_next <= r_byte_cnt;
                        end if;
      
      when s_WA     =>  tx_cyc        <= '1';
                        tx_flush_o    <= '0';
                        tx_stb        <= '1';  
                        rec_fifo_pop  <= '0'; 
                        r_pop_cmd     <= '0';  

                        s_byte_cnt_next <= r_byte_cnt;  

                        if(master_i.stall = '0') then
                          s_ops_cnt_next <= '0' & rec_hdr.wr_cnt -2; -- output write base address
                          s_state_next <= s_WRITE;
                        else
                          s_ops_cnt_next  <= r_ops_cnt;
                          s_state_next <= r_state;       
                        end if;               
      
      when s_WRITE  =>  tx_cyc        <= '1';
                        tx_flush_o    <= '0';
                        tx_stb        <= '1';  
                        rec_fifo_pop  <= '0'; 
                        r_pop_cmd     <= '1';

                        s_byte_cnt_next <= r_byte_cnt;   


                        if(master_i.stall = '0') then
                          s_ops_cnt_next <= r_ops_cnt-1;
                          if(r_ops_cnt(r_ops_cnt'left) = '1') then -- output write values
                            if(or_all(std_logic_vector(rec_hdr.rd_cnt)) = '1') then
                              s_state_next <= s_RA;
                            else
                              s_state_next <= s_LOAD;
                            end if;
                          else
                            s_state_next <= r_state;         
                          end if;
                        else
                          s_ops_cnt_next  <= r_ops_cnt;
                          s_state_next    <= r_state;   
                        end if;
      
      when s_RA     =>  tx_cyc        <= '1';
                        tx_flush_o    <= '0';
                        tx_stb        <= '1';  
                        rec_fifo_pop  <= '0'; 
                        r_pop_cmd     <= '0';

                        s_byte_cnt_next <= r_byte_cnt; 

                        if(master_i.stall = '0') then
                          s_ops_cnt_next <= '0' & rec_hdr.rd_cnt -2; -- output readback address
                          s_state_next <= s_READ;
                        else
                          s_ops_cnt_next <= r_ops_cnt; -- output readback address
                          s_state_next   <= r_state; 
                        end if;  
      
      when s_READ   =>  tx_cyc        <= '1';
                        tx_flush_o    <= '0';
                        tx_stb        <= '1';  
                        rec_fifo_pop  <= '0'; 
                        r_pop_cmd     <= '1';

                        s_byte_cnt_next <= r_byte_cnt;
                        s_state_next    <= r_state;   

                        if(master_i.stall = '0') then
                          s_ops_cnt_next <= r_ops_cnt-1;
                          if(r_ops_cnt(r_ops_cnt'left) = '1') then -- output read addresses
                            s_state_next <= s_LOAD;
                          else
                            s_state_next <= r_state; 
                          end if;
                        else
                          s_state_next    <= r_state; 
                          s_ops_cnt_next  <= r_ops_cnt;
                        end if;
      
      when s_LOAD   =>  tx_cyc        <= '1';
                        tx_flush_o    <= '0';
                        tx_stb        <= '0';
                        rec_fifo_pop  <= '1';
                        r_pop_cmd     <= '0';
                        
                        s_ops_cnt_next  <= r_ops_cnt;
                        s_byte_cnt_next <= r_byte_cnt + r_rec_byte_cnt;        
                        s_state_next  <= s_NEXT;

      when s_NEXT   =>  --clear buffer on outside request?
                        tx_cyc        <= '1';
                        tx_flush_o    <= '0';
                        tx_stb        <= '0';  
                        rec_fifo_pop  <= '0';
                        r_pop_cmd     <= send_now;

                        s_ops_cnt_next  <= r_ops_cnt;
                        s_byte_cnt_next <= r_byte_cnt;      


                        if(send_now = '1' or s_space_sufficient = '0') then
                          s_state_next <= s_SEND;
                        elsif (rec_fifo_empty = '0') then
                          s_state_next <= s_REC;
                        else
                          s_state_next <= r_state;    
                        end if;  
                           
      when s_SEND   =>  tx_cyc        <= '0';
                        tx_flush_o    <= '0';
                        tx_stb        <= '0';  
                        rec_fifo_pop  <= '0'; 
                        r_pop_cmd     <= '1';

                        s_ops_cnt_next  <= r_ops_cnt;
                        s_byte_cnt_next <= r_byte_cnt;       
                        s_state_next    <= s_IDLE;
                        
      when others   =>  tx_cyc        <= '0';
                        tx_flush_o    <= '0';
                        tx_stb        <= '0';  
                        rec_fifo_pop  <= '0'; 
                        r_pop_cmd     <= '0';

                        s_ops_cnt_next  <= r_ops_cnt;
                        s_byte_cnt_next <= r_byte_cnt;   
                        s_state_next    <= s_IDLE;
    end case;




  end process;

end architecture;






